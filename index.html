<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Aditya Fertilizers - Professional Accounting Ledger</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
<style>
:root {
  --primary: #0f766e;
  --primary-dark: #065f57;
  --secondary: #047857;
  --danger: #dc2626;
  --warning: #d97706;
  --success: #059669;
  --bg: #f8fafc;
  --card: #ffffff;
  --border: #e2e8f0;
  --text: #1e293b;
  --text-muted: #64748b;
  --shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
}

.header {
  background: var(--card);
  border-bottom: 1px solid var(--border);
  padding: 1rem 2rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  box-shadow: var(--shadow);
  position: sticky;
  top: 0;
  z-index: 100;
}

.logo {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 700;
  font-size: 1.25rem;
  color: var(--primary);
}

.nav-links {
  display: flex;
  gap: 1rem;
  align-items: center;
}

.nav-btn {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 0.5rem;
  background: transparent;
  color: var(--text);
  cursor: pointer;
  transition: all 0.2s;
  font-weight: 500;
}

.nav-btn:hover {
  background: var(--primary);
  color: white;
}

.nav-btn.active {
  background: var(--primary);
  color: white;
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 2rem;
}

.dashboard-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.stat-card {
  background: var(--card);
  padding: 1.5rem;
  border-radius: 0.75rem;
  box-shadow: var(--shadow);
  border: 1px solid var(--border);
}

.stat-title {
  font-size: 0.875rem;
  color: var(--text-muted);
  margin-bottom: 0.5rem;
}

.stat-value {
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 0.25rem;
}

.stat-change {
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.positive { color: var(--success); }
.negative { color: var(--danger); }
.warning { color: var(--warning); }

.card {
  background: var(--card);
  border-radius: 0.75rem;
  box-shadow: var(--shadow);
  border: 1px solid var(--border);
  overflow: hidden;
}

.card-header {
  padding: 1.5rem 1.5rem 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-title {
  font-size: 1.125rem;
  font-weight: 600;
}

.card-content {
  padding: 1.5rem;
}

.table-container {
  overflow-x: auto;
}

.table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.875rem;
}

.table th,
.table td {
  padding: 0.75rem;
  text-align: left;
  border-bottom: 1px solid var(--border);
}

.table th {
  background: #f8fafc;
  font-weight: 600;
  color: var(--text-muted);
}

.table tr:hover {
  background: #f8fafc;
}

.btn {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 0.5rem;
  cursor: pointer;
  font-weight: 500;
  font-size: 0.875rem;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.btn-primary {
  background: var(--primary);
  color: white;
}

.btn-primary:hover {
  background: var(--primary-dark);
}

.btn-secondary {
  background: var(--border);
  color: var(--text);
}

.btn-secondary:hover {
  background: #cbd5e1;
}

.btn-danger {
  background: var(--danger);
  color: white;
}

.btn-success {
  background: var(--success);
  color: white;
}

.btn-warning {
  background: var(--warning);
  color: white;
}

.btn-sm {
  padding: 0.25rem 0.5rem;
  font-size: 0.75rem;
}

.form-group {
  margin-bottom: 1rem;
}

.label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
  color: var(--text);
}

.input,
.select,
.textarea {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  font-size: 0.875rem;
  transition: border-color 0.2s;
}

.input:focus,
.select:focus,
.textarea:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(15, 118, 110, 0.1);
}

.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 1rem;
}

.modal {
  background: var(--card);
  border-radius: 0.75rem;
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 600px;
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  padding: 1.5rem;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-title {
  font-size: 1.25rem;
  font-weight: 600;
}

.modal-content {
  padding: 1.5rem;
}

.modal-footer {
  padding: 1.5rem;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
}

.badge {
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  font-size: 0.75rem;
  font-weight: 500;
}

.badge-success { background: #dcfce7; color: var(--success); }
.badge-danger { background: #fecaca; color: var(--danger); }
.badge-warning { background: #fef3c7; color: var(--warning); }
.badge-secondary { background: #f1f5f9; color: var(--text-muted); }

.search-bar {
  position: relative;
  margin-bottom: 1.5rem;
}

.search-input {
  padding-left: 2.5rem;
}

.search-icon {
  position: absolute;
  left: 0.75rem;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text-muted);
}

.filters {
  display: flex;
  gap: 1rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
}

.loader {
  position: fixed;
  inset: 0;
  background: rgba(255, 255, 255, 0.9);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid var(--border);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.actions {
  display: flex;
  gap: 0.5rem;
}

.text-right { text-align: right; }
.text-center { text-align: center; }
.font-medium { font-weight: 500; }
.text-sm { font-size: 0.875rem; }
.text-xs { font-size: 0.75rem; }

.grid {
  display: grid;
  gap: 1rem;
}

.grid-cols-2 {
  grid-template-columns: repeat(2, 1fr);
}

.grid-cols-3 {
  grid-template-columns: repeat(3, 1fr);
}

.hidden {
  display: none !important;
}

@media (max-width: 768px) {
  .container {
    padding: 1rem;
  }
  
  .dashboard-grid {
    grid-template-columns: 1fr;
  }
  
  .header {
    padding: 1rem;
  }
  
  .nav-links {
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .filters {
    flex-direction: column;
  }
  
  .table-container {
    font-size: 0.75rem;
  }
}
</style>
</head>

<body>
  <div class="loader" id="loader">
    <div class="spinner"></div>
  </div>

  <header class="header">
    <div class="logo">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
      </svg>
      Aditya Fertilizers - Accounting Ledger
    </div>
    <nav class="nav-links">
      <button class="nav-btn active" data-section="dashboard">Dashboard</button>
      <button class="nav-btn" data-section="accounts">Accounts</button>
      <button class="nav-btn" data-section="transactions">Transactions</button>
      <button class="nav-btn" data-section="reports">Reports</button>
      <button class="nav-btn" data-section="settings">Settings</button>
    </nav>
  </header>

  <main class="container">
    <!-- Dashboard Section -->
    <div id="dashboard-section" class="section">
      <div class="dashboard-grid">
        <div class="stat-card">
          <div class="stat-title">Total Receivables</div>
          <div class="stat-value" id="totalReceivables">₹0</div>
          <div class="stat-change positive">
            <span>Outstanding from customers</span>
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-title">Total Payables</div>
          <div class="stat-value" id="totalPayables">₹0</div>
          <div class="stat-change negative">
            <span>Outstanding to suppliers</span>
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-title">Net Position</div>
          <div class="stat-value" id="netPosition">₹0</div>
          <div class="stat-change" id="netPositionChange">
            <span>Overall financial position</span>
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-title">This Month Sales</div>
          <div class="stat-value" id="monthSales">₹0</div>
          <div class="stat-change positive">
            <span>Current month revenue</span>
          </div>
        </div>
      </div>

      <div class="grid grid-cols-2">
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">Recent Transactions</h3>
            <button class="btn btn-primary btn-sm" onclick="showAddTransactionModal()">Add Transaction</button>
          </div>
          <div class="card-content">
            <div id="recentTransactions">Loading...</div>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <h3 class="card-title">Outstanding Payments</h3>
          </div>
          <div class="card-content">
            <div id="outstandingPayments">Loading...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Accounts Section -->
    <div id="accounts-section" class="section hidden">
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">Company Accounts</h3>
          <button class="btn btn-primary" onclick="showAddAccountModal()">Add Account</button>
        </div>
        <div class="card-content">
          <div class="search-bar">
            <input type="text" class="input search-input" placeholder="Search accounts..." id="accountSearch">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="21 21l-4.35-4.35"></path>
            </svg>
          </div>
          <div class="table-container">
            <table class="table" id="accountsTable">
              <thead>
                <tr>
                  <th>Company Name</th>
                  <th>Type</th>
                  <th>Balance</th>
                  <th>Status</th>
                  <th>Last Transaction</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="accountsTableBody">
                <!-- Dynamic content -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Transactions Section -->
    <div id="transactions-section" class="section hidden">
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">All Transactions</h3>
          <button class="btn btn-primary" onclick="showAddTransactionModal()">Add Transaction</button>
        </div>
        <div class="card-content">
          <div class="filters">
            <select class="select" id="transactionTypeFilter">
              <option value="">All Types</option>
              <option value="purchase">Purchase</option>
              <option value="sale">Sale</option>
              <option value="payment">Payment</option>
              <option value="receipt">Receipt</option>
            </select>
            <select class="select" id="paymentStatusFilter">
              <option value="">All Status</option>
              <option value="pending">Pending</option>
              <option value="partial">Partial</option>
              <option value="paid">Paid</option>
            </select>
            <input type="date" class="input" id="fromDate">
            <input type="date" class="input" id="toDate">
            <button class="btn btn-secondary" onclick="applyFilters()">Apply Filters</button>
            <button class="btn btn-secondary" onclick="clearFilters()">Clear</button>
          </div>
          <div class="search-bar">
            <input type="text" class="input search-input" placeholder="Search transactions..." id="transactionSearch">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="21 21l-4.35-4.35"></path>
            </svg>
          </div>
          <div class="table-container">
            <table class="table" id="transactionsTable">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Company</th>
                  <th>Type</th>
                  <th>Material</th>
                  <th>Quantity</th>
                  <th>Amount</th>
                  <th>Payment Status</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="transactionsTableBody">
                <!-- Dynamic content -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Reports Section -->
    <div id="reports-section" class="section hidden">
      <div class="grid grid-cols-2">
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">Profit & Loss</h3>
          </div>
          <div class="card-content">
            <canvas id="profitLossChart" width="400" height="200"></canvas>
          </div>
        </div>
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">Outstanding Analysis</h3>
          </div>
          <div class="card-content">
            <canvas id="outstandingChart" width="400" height="200"></canvas>
          </div>
        </div>
      </div>
      
      <div class="card" style="margin-top: 1.5rem;">
        <div class="card-header">
          <h3 class="card-title">Generate Reports</h3>
        </div>
        <div class="card-content">
          <div class="grid grid-cols-3">
            <button class="btn btn-primary" onclick="generateReport('aging')">Aging Report</button>
            <button class="btn btn-primary" onclick="generateReport('pl')">P&L Statement</button>
            <button class="btn btn-primary" onclick="generateReport('ledger')">Ledger Summary</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Settings Section -->
    <div id="settings-section" class="section hidden">
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">System Settings</h3>
        </div>
        <div class="card-content">
          <div class="grid grid-cols-2">
            <button class="btn btn-primary" onclick="syncWithSupplyChain()">Sync with Supply Chain</button>
            <button class="btn btn-secondary" onclick="exportData()">Export Data</button>
            <button class="btn btn-warning" onclick="clearDuplicateTransactions()">Clear Duplicates</button>
            <button class="btn btn-warning" onclick="clearCache()">Clear Cache</button>
            <button class="btn btn-danger" onclick="resetSystem()">Reset System</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Add Transaction Modal -->
  <div id="transactionModal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Add Transaction</h3>
        <button onclick="hideModal('transactionModal')" class="btn btn-secondary btn-sm">✕</button>
      </div>
      <div class="modal-content">
        <form id="transactionForm">
          <div class="form-group">
            <label class="label">Transaction Type</label>
            <select class="select" id="transactionType" required>
              <option value="">Select Type</option>
              <option value="purchase">Purchase</option>
              <option value="sale">Sale</option>
              <option value="payment">Payment Made</option>
              <option value="receipt">Payment Received</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="label">Company</label>
            <select class="select" id="transactionCompany" required>
              <option value="">Select Company</option>
              <!-- Dynamic options -->
            </select>
          </div>
          
          <div class="form-group" id="materialGroup">
            <label class="label">Material</label>
            <select class="select" id="transactionMaterial">
              <option value="">Select Material</option>
              <!-- Dynamic options -->
            </select>
          </div>
          
          <div class="grid grid-cols-2">
            <div class="form-group" id="quantityGroup">
              <label class="label">Quantity (Bags)</label>
              <input type="number" class="input" id="transactionQuantity" step="0.01">
            </div>
            <div class="form-group" id="priceGroup">
              <label class="label">Price per Bag</label>
              <input type="number" class="input" id="transactionPrice" step="0.01">
            </div>
          </div>
          
          <div class="form-group">
            <label class="label">Total Amount</label>
            <input type="number" class="input" id="transactionAmount" step="0.01" required>
          </div>
          
          <div class="form-group">
            <label class="label">Payment Status</label>
            <select class="select" id="paymentStatus" required>
              <option value="pending">Pending</option>
              <option value="partial">Partial</option>
              <option value="paid">Paid</option>
            </select>
          </div>
          
          <div class="form-group" id="paidAmountGroup" style="display: none;">
            <label class="label">Paid Amount</label>
            <input type="number" class="input" id="paidAmount" step="0.01">
          </div>
          
          <div class="form-group">
            <label class="label">Notes</label>
            <textarea class="textarea" id="transactionNotes" rows="3"></textarea>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideModal('transactionModal')">Cancel</button>
        <button class="btn btn-primary" onclick="saveTransaction()">Save Transaction</button>
      </div>
    </div>
  </div>

  <!-- Add Account Modal -->
  <div id="accountModal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Add Company Account</h3>
        <button onclick="hideModal('accountModal')" class="btn btn-secondary btn-sm">✕</button>
      </div>
      <div class="modal-content">
        <form id="accountForm">
          <div class="form-group">
            <label class="label">Company Name</label>
            <input type="text" class="input" id="accountName" required>
          </div>
          
          <div class="form-group">
            <label class="label">Account Type</label>
            <select class="select" id="accountType" required>
              <option value="customer">Customer</option>
              <option value="supplier">Supplier</option>
              <option value="both">Both</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="label">Contact Person</label>
            <input type="text" class="input" id="contactPerson">
          </div>
          
          <div class="form-group">
            <label class="label">Phone</label>
            <input type="tel" class="input" id="accountPhone">
          </div>
          
          <div class="form-group">
            <label class="label">Address</label>
            <textarea class="textarea" id="accountAddress" rows="3"></textarea>
          </div>
          
          <div class="form-group">
            <label class="label">Opening Balance</label>
            <input type="number" class="input" id="openingBalance" step="0.01" placeholder="0.00">
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideModal('accountModal')">Cancel</button>
        <button class="btn btn-primary" onclick="saveAccount()">Save Account</button>
      </div>
    </div>
  </div>

  <script>
 // Firebase Configuration
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyBEybu3XKeK3QOeRIMs-fK2dDwHtpCTqgQ",
  authDomain: "aditya-supply-chain-b5f61.firebaseapp.com",
  projectId: "aditya-supply-chain-b5f61",
  storageBucket: "aditya-supply-chain-b5f61.firebasestorage.app",
  messagingSenderId: "662836162599",
  appId: "1:662836162599:web:2b49bde530e4b87924de02",
  measurementId: "G-DQH00BNH1L"
};

// Admin credentials
const ADMIN_EMAIL = 'adityajainaas@gmail.com';
const ADMIN_PWD = 'Aditya@1609';

// Initialize Firebase
firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();
const auth = firebase.auth();

// Global state
let currentSection = 'dashboard';
let accounts = new Map();
let transactions = [];
let materials = [];
let transactionHistory = new Map();
let accountBalances = new Map();

// Utility functions
function formatCurrency(amount) {
  return '₹' + Number(amount || 0).toLocaleString('en-IN', { 
    minimumFractionDigits: 2,
    maximumFractionDigits: 2 
  });
}

function formatDate(date) {
  if (!date) return '-';
  if (date.toDate) return date.toDate().toLocaleDateString('en-IN');
  if (date.seconds) return new Date(date.seconds * 1000).toLocaleDateString('en-IN');
  return new Date(date).toLocaleDateString('en-IN');
}

function generateTransactionNumber() {
  const now = new Date();
  const year = now.getFullYear().toString().substr(-2);
  const month = (now.getMonth() + 1).toString().padStart(2, '0');
  const day = now.getDate().toString().padStart(2, '0');
  const time = now.getTime().toString().substr(-6);
  return `TXN${year}${month}${day}${time}`;
}

function showLoader() {
  document.getElementById('loader').style.display = 'flex';
}

function hideLoader() {
  document.getElementById('loader').style.display = 'none';
}

function showModal(modalId) {
  document.getElementById(modalId).classList.remove('hidden');
}

function hideModal(modalId) {
  document.getElementById(modalId).classList.add('hidden');
}

// Authentication
async function autoSignIn() {
  try {
    await auth.signInWithEmailAndPassword(ADMIN_EMAIL, ADMIN_PWD);
    console.log('Authenticated successfully');
  } catch (err) {
    console.error('Authentication failed:', err);
    throw new Error('Authentication failed: ' + err.message);
  }
}

// Account Management Class
class AccountManager {
  constructor() {
    this.accounts = new Map();
    this.balances = new Map();
  }

  async createAccount(accountData) {
    const accountId = accountData.id || db.collection('ledger_accounts').doc().id;
    
    const account = {
      id: accountId,
      name: accountData.name,
      type: accountData.type, // 'customer', 'supplier', 'both'
      contactPerson: accountData.contactPerson || '',
      phone: accountData.phone || '',
      address: accountData.address || '',
      openingBalance: parseFloat(accountData.openingBalance) || 0,
      currentBalance: parseFloat(accountData.openingBalance) || 0,
      totalPurchases: 0,
      totalSales: 0,
      totalPayments: 0,
      totalReceipts: 0,
      outstandingReceivable: accountData.type === 'customer' || accountData.type === 'both' ? 0 : null,
      outstandingPayable: accountData.type === 'supplier' || accountData.type === 'both' ? parseFloat(accountData.openingBalance) || 0 : null,
      creditLimit: parseFloat(accountData.creditLimit) || 0,
      paymentTerms: accountData.paymentTerms || 'immediate',
      status: 'active',
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    await db.collection('ledger_accounts').doc(accountId).set(account);
    this.accounts.set(accountId, account);
    
    return account;
  }

  async updateAccountBalance(accountId, transactionType, amount, operation = 'add') {
    const account = this.accounts.get(accountId);
    if (!account) throw new Error('Account not found');

    const multiplier = operation === 'add' ? 1 : -1;
    const adjustedAmount = amount * multiplier;

    const updateData = {
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    switch (transactionType) {
      case 'purchase':
        updateData.totalPurchases = firebase.firestore.FieldValue.increment(adjustedAmount);
        updateData.outstandingPayable = firebase.firestore.FieldValue.increment(adjustedAmount);
        updateData.currentBalance = firebase.firestore.FieldValue.increment(-adjustedAmount);
        break;
      case 'sale':
        updateData.totalSales = firebase.firestore.FieldValue.increment(adjustedAmount);
        updateData.outstandingReceivable = firebase.firestore.FieldValue.increment(adjustedAmount);
        updateData.currentBalance = firebase.firestore.FieldValue.increment(adjustedAmount);
        break;
      case 'payment':
        updateData.totalPayments = firebase.firestore.FieldValue.increment(adjustedAmount);
        updateData.outstandingPayable = firebase.firestore.FieldValue.increment(-adjustedAmount);
        updateData.currentBalance = firebase.firestore.FieldValue.increment(adjustedAmount);
        break;
      case 'receipt':
        updateData.totalReceipts = firebase.firestore.FieldValue.increment(adjustedAmount);
        updateData.outstandingReceivable = firebase.firestore.FieldValue.increment(-adjustedAmount);
        updateData.currentBalance = firebase.firestore.FieldValue.increment(-adjustedAmount);
        break;
    }

    await db.collection('ledger_accounts').doc(accountId).update(updateData);
    
    // Update local cache
    const currentAccount = await db.collection('ledger_accounts').doc(accountId).get();
    this.accounts.set(accountId, { id: accountId, ...currentAccount.data() });
  }

  getAccountBalance(accountId) {
    const account = this.accounts.get(accountId);
    return account ? account.currentBalance || 0 : 0;
  }

  getOutstandingReceivable(accountId) {
    const account = this.accounts.get(accountId);
    return account ? account.outstandingReceivable || 0 : 0;
  }

  getOutstandingPayable(accountId) {
    const account = this.accounts.get(accountId);
    return account ? account.outstandingPayable || 0 : 0;
  }
}

// Transaction Management Class
class TransactionManager {
  constructor(accountManager) {
    this.accountManager = accountManager;
    this.transactions = [];
    this.paymentHistory = new Map();
  }

  async createTransaction(transactionData) {
    const transactionId = db.collection('ledger_transactions').doc().id;
    const transactionNumber = generateTransactionNumber();

    // Validate transaction data
    this.validateTransaction(transactionData);

    const baseTransaction = {
      id: transactionId,
      transactionNumber: transactionNumber,
      companyId: transactionData.companyId,
      companyName: transactionData.companyName,
      type: transactionData.type, // 'purchase', 'sale', 'payment', 'receipt'
      date: transactionData.date || new Date(),
      
      // Material details (for purchase/sale)
      materialId: transactionData.materialId || null,
      materialName: transactionData.materialName || '',
      quantity: parseFloat(transactionData.quantity) || 0,
      unit: transactionData.unit || 'bags',
      pricePerUnit: parseFloat(transactionData.pricePerUnit) || 0,
      
      // Financial details
      totalAmount: parseFloat(transactionData.totalAmount),
      taxAmount: parseFloat(transactionData.taxAmount) || 0,
      discountAmount: parseFloat(transactionData.discountAmount) || 0,
      netAmount: parseFloat(transactionData.totalAmount) - parseFloat(transactionData.discountAmount || 0) + parseFloat(transactionData.taxAmount || 0),
      
      // Payment details
      paymentStatus: transactionData.paymentStatus || 'pending',
      paidAmount: parseFloat(transactionData.paidAmount) || 0,
      pendingAmount: 0, // Will be calculated
      paymentMethod: transactionData.paymentMethod || 'cash',
      paymentReference: transactionData.paymentReference || '',
      
      // Additional details
      party: transactionData.party || '',
      vehicleNumber: transactionData.vehicleNumber || '',
      invoiceNumber: transactionData.invoiceNumber || '',
      notes: transactionData.notes || '',
      
      // Audit trail
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      createdBy: 'system',
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      status: 'active',
      
      // Payment history
      paymentHistory: [],
      
      // Linking
      parentTransactionId: transactionData.parentTransactionId || null,
      linkedTransactions: [],
      
      // Accounting entries
      journalEntries: []
    };

    // Calculate pending amount
    if (baseTransaction.paymentStatus === 'paid') {
      baseTransaction.paidAmount = baseTransaction.netAmount;
      baseTransaction.pendingAmount = 0;
    } else if (baseTransaction.paymentStatus === 'partial') {
      baseTransaction.pendingAmount = baseTransaction.netAmount - baseTransaction.paidAmount;
    } else {
      baseTransaction.paidAmount = 0;
      baseTransaction.pendingAmount = baseTransaction.netAmount;
    }

    // Create initial payment record if partially or fully paid
    if (baseTransaction.paidAmount > 0) {
      baseTransaction.paymentHistory.push({
        id: db.collection('payment_history').doc().id,
        amount: baseTransaction.paidAmount,
        method: baseTransaction.paymentMethod,
        reference: baseTransaction.paymentReference,
        date: baseTransaction.date,
        notes: 'Initial payment',
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      });
    }

    // Generate journal entries for double-entry bookkeeping
    baseTransaction.journalEntries = this.generateJournalEntries(baseTransaction);

    // Save transaction
    await db.collection('ledger_transactions').doc(transactionId).set(baseTransaction);
    
    // Update account balance
    await this.accountManager.updateAccountBalance(
      baseTransaction.companyId,
      baseTransaction.type,
      baseTransaction.netAmount
    );

    // If there's a payment, create separate payment entry
    if (baseTransaction.paidAmount > 0) {
      const paymentType = baseTransaction.type === 'sale' ? 'receipt' : 'payment';
      await this.accountManager.updateAccountBalance(
        baseTransaction.companyId,
        paymentType,
        baseTransaction.paidAmount
      );
    }

    this.transactions.push(baseTransaction);
    return baseTransaction;
  }

  validateTransaction(data) {
    if (!data.companyId) throw new Error('Company ID is required');
    if (!data.type || !['purchase', 'sale', 'payment', 'receipt'].includes(data.type)) {
      throw new Error('Valid transaction type is required');
    }
    if (!data.totalAmount || data.totalAmount <= 0) {
      throw new Error('Valid total amount is required');
    }
    if (data.paidAmount && data.paidAmount > data.totalAmount) {
      throw new Error('Paid amount cannot exceed total amount');
    }
  }

  generateJournalEntries(transaction) {
    const entries = [];
    
    switch (transaction.type) {
      case 'purchase':
        entries.push({
          account: 'Purchases',
          debit: transaction.netAmount,
          credit: 0,
          description: `Purchase from ${transaction.companyName}`
        });
        entries.push({
          account: transaction.companyName,
          debit: 0,
          credit: transaction.netAmount,
          description: `Purchase liability`
        });
        break;
        
      case 'sale':
        entries.push({
          account: transaction.companyName,
          debit: transaction.netAmount,
          credit: 0,
          description: `Sale to ${transaction.companyName}`
        });
        entries.push({
          account: 'Sales',
          debit: 0,
          credit: transaction.netAmount,
          description: `Sale revenue`
        });
        break;
        
      case 'payment':
        entries.push({
          account: transaction.companyName,
          debit: transaction.totalAmount,
          credit: 0,
          description: `Payment made to ${transaction.companyName}`
        });
        entries.push({
          account: 'Cash/Bank',
          debit: 0,
          credit: transaction.totalAmount,
          description: `Payment outflow`
        });
        break;
        
      case 'receipt':
        entries.push({
          account: 'Cash/Bank',
          debit: transaction.totalAmount,
          credit: 0,
          description: `Receipt from ${transaction.companyName}`
        });
        entries.push({
          account: transaction.companyName,
          debit: 0,
          credit: transaction.totalAmount,
          description: `Receipt against receivable`
        });
        break;
    }
    
    return entries;
  }

  async updatePaymentStatus(transactionId, paymentData) {
    const transaction = this.transactions.find(t => t.id === transactionId);
    if (!transaction) {
      const doc = await db.collection('ledger_transactions').doc(transactionId).get();
      if (!doc.exists) throw new Error('Transaction not found');
    }

    const currentTransaction = transaction || { id: transactionId, ...doc.data() };
    
    const paymentRecord = {
      id: db.collection('payment_history').doc().id,
      transactionId: transactionId,
      amount: parseFloat(paymentData.amount),
      method: paymentData.method || 'cash',
      reference: paymentData.reference || '',
      date: paymentData.date || new Date(),
      notes: paymentData.notes || '',
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    const newPaidAmount = (currentTransaction.paidAmount || 0) + paymentRecord.amount;
    const newPendingAmount = currentTransaction.netAmount - newPaidAmount;
    
    let newStatus = 'pending';
    if (newPendingAmount <= 0) {
      newStatus = 'paid';
    } else if (newPaidAmount > 0) {
      newStatus = 'partial';
    }

    const updateData = {
      paidAmount: newPaidAmount,
      pendingAmount: Math.max(0, newPendingAmount),
      paymentStatus: newStatus,
      paymentHistory: firebase.firestore.FieldValue.arrayUnion(paymentRecord),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    await db.collection('ledger_transactions').doc(transactionId).update(updateData);
    
    // Update account balance for the payment
    const paymentType = currentTransaction.type === 'sale' ? 'receipt' : 'payment';
    await this.accountManager.updateAccountBalance(
      currentTransaction.companyId,
      paymentType,
      paymentRecord.amount
    );

    // Store payment history
    await db.collection('payment_history').doc(paymentRecord.id).set(paymentRecord);

    return paymentRecord;
  }

  async getTransactionHistory(companyId) {
    const snapshot = await db.collection('ledger_transactions')
      .where('companyId', '==', companyId)
      .orderBy('createdAt', 'desc')
      .get();
    
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  }

  async getPaymentHistory(transactionId) {
    const snapshot = await db.collection('payment_history')
      .where('transactionId', '==', transactionId)
      .orderBy('createdAt', 'desc')
      .get();
    
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  }
}

// Initialize managers
const accountManager = new AccountManager();
const transactionManager = new TransactionManager(accountManager);

// Navigation functions
function showSection(sectionName) {
  document.querySelectorAll('.section').forEach(section => {
    section.classList.add('hidden');
  });
  
  document.querySelectorAll('.nav-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  
  document.getElementById(sectionName + '-section').classList.remove('hidden');
  document.querySelector(`[data-section="${sectionName}"]`).classList.add('active');
  
  currentSection = sectionName;
  
  // Load section data
  switch (sectionName) {
    case 'dashboard':
      loadDashboard();
      break;
    case 'accounts':
      loadAccounts();
      break;
    case 'transactions':
      loadTransactions();
      break;
    case 'reports':
      loadReports();
      break;
  }
}

// Data loading functions
async function loadAccounts() {
  showLoader();
  try {
    const snapshot = await db.collection('ledger_accounts')
      .orderBy('name')
      .get();
    
    const tbody = document.getElementById('accountsTableBody');
    tbody.innerHTML = '';
    
    accountManager.accounts.clear();
    
    snapshot.forEach(doc => {
      const account = { id: doc.id, ...doc.data() };
      accountManager.accounts.set(doc.id, account);
      
      const balance = (account.outstandingReceivable || 0) - (account.outstandingPayable || 0);
      const balanceClass = balance > 0 ? 'positive' : balance < 0 ? 'negative' : '';
      const status = balance === 0 ? 'Settled' : balance > 0 ? 'Receivable' : 'Payable';
      const statusClass = balance === 0 ? 'badge-success' : balance > 0 ? 'badge-warning' : 'badge-danger';
      
      const row = `
        <tr>
          <td class="font-medium">
            <div>${account.name}</div>
            <div class="text-xs text-gray-500">${account.contactPerson || ''} ${account.phone || ''}</div>
          </td>
          <td><span class="badge badge-secondary">${account.type}</span></td>
          <td class="${balanceClass}">
            <div class="font-medium">${formatCurrency(Math.abs(balance))}</div>
            <div class="text-xs">R: ${formatCurrency(account.outstandingReceivable || 0)} | P: ${formatCurrency(account.outstandingPayable || 0)}</div>
          </td>
          <td><span class="badge ${statusClass}">${status}</span></td>
          <td class="text-sm">${formatDate(account.updatedAt)}</td>
          <td>
            <div class="actions">
              <button class="btn btn-primary btn-sm" onclick="viewAccountLedger('${doc.id}')">Ledger</button>
              <button class="btn btn-secondary btn-sm" onclick="editAccount('${doc.id}')">Edit</button>
              <button class="btn btn-danger btn-sm" onclick="deleteAccount('${doc.id}')">Delete</button>
            </div>
          </td>
        </tr>
      `;
      tbody.innerHTML += row;
    });
    
  } catch (error) {
    console.error('Error loading accounts:', error);
    showNotification('Error loading accounts: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

async function loadTransactions() {
  showLoader();
  try {
    const snapshot = await db.collection('ledger_transactions')
      .orderBy('createdAt', 'desc')
      .limit(100)
      .get();
    
    const tbody = document.getElementById('transactionsTableBody');
    tbody.innerHTML = '';
    
    transactionManager.transactions = [];
    
    for (const doc of snapshot.docs) {
      const transaction = { id: doc.id, ...doc.data() };
      transactionManager.transactions.push(transaction);
      
      // Get company name
      const account = accountManager.accounts.get(transaction.companyId);
      const companyName = account ? account.name : transaction.companyName || 'Unknown';
      
      const statusClass = transaction.paymentStatus === 'paid' ? 'badge-success' : 
                         transaction.paymentStatus === 'partial' ? 'badge-warning' : 'badge-danger';
      
      const typeClass = transaction.type === 'sale' || transaction.type === 'receipt' ? 'positive' : 'negative';
      const typeIcon = getTransactionIcon(transaction.type);
      
      const row = `
        <tr onclick="viewTransactionDetails('${doc.id}')" style="cursor: pointer;">
          <td class="text-sm">
            <div>${formatDate(transaction.createdAt)}</div>
            <div class="text-xs text-gray-500">${transaction.transactionNumber || doc.id.substr(0, 8)}</div>
          </td>
          <td class="font-medium">
            <div>${companyName}</div>
            <div class="text-xs text-gray-500">${transaction.party || ''}</div>
          </td>
          <td>
            <span class="badge badge-secondary">${typeIcon} ${transaction.type.toUpperCase()}</span>
          </td>
          <td>
            <div>${transaction.materialName || '-'}</div>
            <div class="text-xs text-gray-500">${transaction.invoiceNumber || ''}</div>
          </td>
          <td class="text-right">
            ${transaction.quantity ? `${transaction.quantity} ${transaction.unit}` : '-'}
            ${transaction.pricePerUnit ? `<div class="text-xs text-gray-500">@ ${formatCurrency(transaction.pricePerUnit)}</div>` : ''}
          </td>
          <td class="text-right">
            <div class="font-medium ${typeClass}">${formatCurrency(transaction.netAmount || transaction.totalAmount)}</div>
            <div class="text-xs text-gray-500">Paid: ${formatCurrency(transaction.paidAmount || 0)}</div>
          </td>
          <td>
            <span class="badge ${statusClass}">${transaction.paymentStatus.toUpperCase()}</span>
            ${transaction.pendingAmount > 0 ? `<div class="text-xs text-red-600">Pending: ${formatCurrency(transaction.pendingAmount)}</div>` : ''}
          </td>
          <td>
            <div class="actions">
              <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); updatePayment('${doc.id}')">Payment</button>
              <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); editTransaction('${doc.id}')">Edit</button>
              <button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); deleteTransaction('${doc.id}')">Delete</button>
            </div>
          </td>
        </tr>
      `;
      tbody.innerHTML += row;
    }
    
  } catch (error) {
    console.error('Error loading transactions:', error);
    showNotification('Error loading transactions: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

function getTransactionIcon(type) {
  const icons = {
    purchase: '📦',
    sale: '💰',
    payment: '💸',
    receipt: '💵'
  };
  return icons[type] || '📄';
}

async function loadDashboard() {
  showLoader();
  try {
    // Load account summaries
    const accountsSnapshot = await db.collection('ledger_accounts').get();
    let totalReceivables = 0;
    let totalPayables = 0;
    let activeCustomers = 0;
    let activeSuppliers = 0;
    
    accountsSnapshot.forEach(doc => {
      const account = doc.data();
      totalReceivables += account.outstandingReceivable || 0;
      totalPayables += account.outstandingPayable || 0;
      
      if (account.outstandingReceivable > 0) activeCustomers++;
      if (account.outstandingPayable > 0) activeSuppliers++;
    });
    
    // Calculate this month's sales and purchases
    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);
    
    const transactionsSnapshot = await db.collection('ledger_transactions')
      .where('createdAt', '>=', startOfMonth)
      .get();
    
    let monthSales = 0;
    let monthPurchases = 0;
    
    transactionsSnapshot.forEach(doc => {
      const transaction = doc.data();
      if (transaction.type === 'sale') {
        monthSales += transaction.netAmount || transaction.totalAmount || 0;
      } else if (transaction.type === 'purchase') {
        monthPurchases += transaction.netAmount || transaction.totalAmount || 0;
      }
    });
    
    const netPosition = totalReceivables - totalPayables;
    const monthProfit = monthSales - monthPurchases;
    
    // Update dashboard stats
    document.getElementById('totalReceivables').textContent = formatCurrency(totalReceivables);
    document.getElementById('totalPayables').textContent = formatCurrency(totalPayables);
    document.getElementById('netPosition').textContent = formatCurrency(netPosition);
    document.getElementById('monthSales').textContent = formatCurrency(monthSales);
    
    // Update net position styling
    const netPositionChange = document.getElementById('netPositionChange');
    if (netPosition > 0) {
      netPositionChange.className = 'stat-change positive';
      netPositionChange.innerHTML = '<span>🟢 Favorable position</span>';
    } else if (netPosition < 0) {
      netPositionChange.className = 'stat-change negative';
      netPositionChange.innerHTML = '<span>🔴 Outstanding payables</span>';
    } else {
      netPositionChange.className = 'stat-change';
      netPositionChange.innerHTML = '<span>⚪ Balanced position</span>';
    }
    
    await loadRecentTransactions();
    await loadOutstandingPayments();
    
  } catch (error) {
    console.error('Error loading dashboard:', error);
    showNotification('Error loading dashboard: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

async function loadRecentTransactions() {
  try {
    const snapshot = await db.collection('ledger_transactions')
      .orderBy('createdAt', 'desc')
      .limit(8)
      .get();
    
    const container = document.getElementById('recentTransactions');
    if (snapshot.empty) {
      container.innerHTML = '<div class="text-center text-gray-500 py-4">No transactions yet</div>';
      return;
    }
    
    let html = '';
    for (const doc of snapshot.docs) {
      const transaction = doc.data();
      const account = accountManager.accounts.get(transaction.companyId);
      const companyName = account ? account.name : transaction.companyName || 'Unknown';
      
      const typeClass = transaction.type === 'sale' || transaction.type === 'receipt' ? 'positive' : 'negative';
      const typeIcon = getTransactionIcon(transaction.type);
      const statusColor = transaction.paymentStatus === 'paid' ? '#10b981' : 
                         transaction.paymentStatus === 'partial' ? '#f59e0b' : '#ef4444';
      
      html += `
        <div class="flex justify-between items-center py-3 border-b border-gray-100 hover:bg-gray-50 cursor-pointer" 
             onclick="viewTransactionDetails('${doc.id}')"
             style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0; border-bottom: 1px solid #f3f4f6;">
          <div class="flex-1">
            <div class="font-medium text-sm flex items-center gap-2">
              <span>${typeIcon}</span>
              <span>${companyName}</span>
            </div>
            <div class="text-xs text-gray-500" style="font-size: 0.75rem; color: #6b7280;">
              ${transaction.type.toUpperCase()} • ${formatDate(transaction.createdAt)}
              ${transaction.materialName ? ` • ${transaction.materialName}` : ''}
            </div>
          </div>
          <div class="text-right" style="text-align: right;">
            <div class="font-medium ${typeClass}">${formatCurrency(transaction.netAmount || transaction.totalAmount)}</div>
            <div class="text-xs" style="font-size: 0.75rem; color: ${statusColor};">
              ${transaction.paymentStatus.toUpperCase()}
              ${transaction.pendingAmount > 0 ? ` (₹${(transaction.pendingAmount || 0).toLocaleString()})` : ''}
            </div>
          </div>
        </div>
      `;
    }
    
    container.innerHTML = html;
    
  } catch (error) {
    console.error('Error loading recent transactions:', error);
    document.getElementById('recentTransactions').innerHTML = 
      '<div class="text-center text-red-500 py-4">Error loading transactions</div>';
  }
}

async function loadOutstandingPayments() {
  try {
    const snapshot = await db.collection('ledger_accounts')
      .where('outstandingReceivable', '>', 0)
      .orderBy('outstandingReceivable', 'desc')
      .limit(8)
      .get();
    
    const container = document.getElementById('outstandingPayments');
    if (snapshot.empty) {
      container.innerHTML = '<div class="text-center text-gray-500 py-4">No outstanding payments</div>';
      return;
    }
    
    let html = '';
    snapshot.forEach(doc => {
      const account = doc.data();
      const urgencyClass = account.outstandingReceivable > 50000 ? 'text-red-600' : 
                          account.outstandingReceivable > 20000 ? 'text-yellow-600' : 'text-green-600';
      
      html += `
        <div class="flex justify-between items-center py-3 border-b border-gray-100 hover:bg-gray-50 cursor-pointer" 
             onclick="recordPayment('${doc.id}')"
             style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0; border-bottom: 1px solid #f3f4f6;">
          <div class="flex-1">
            <div class="font-medium text-sm">${account.name}</div>
            <div class="text-xs text-gray-500" style="font-size: 0.75rem; color: #6b7280;">
              Outstanding Receivable • Last updated: ${formatDate(account.updatedAt)}
            </div>
          </div>
          <div class="text-right" style="text-align: right;">
            <div class="font-medium ${urgencyClass}">${formatCurrency(account.outstandingReceivable)}</div>
            <button class="text-xs btn btn-primary btn-sm" 
                    onclick="event.stopPropagation(); recordPayment('${doc.id}')" 
                    style="font-size: 0.75rem; margin-top: 0.25rem;">
              Record Payment
            </button>
          </div>
        </div>
      `;
    });
    
    container.innerHTML = html;
    
  } catch (error) {
    console.error('Error loading outstanding payments:', error);
    document.getElementById('outstandingPayments').innerHTML = 
      '<div class="text-center text-red-500 py-4">Error loading payments</div>';
  }
}

async function populateCompanyDropdowns() {
  try {
    const accountsSnapshot = await db.collection('ledger_accounts')
      .orderBy('name')
      .get();
    
    const companySelect = document.getElementById('transactionCompany');
    if (companySelect) {
      companySelect.innerHTML = '<option value="">Select Company</option>';
      
      accountsSnapshot.forEach(doc => {
        const account = doc.data();
        const option = document.createElement('option');
        option.value = doc.id;
        option.textContent = account.name;
        option.setAttribute('data-type', account.type);
        companySelect.appendChild(option);
      });
    }
  } catch (error) {
    console.error('Error populating company dropdown:', error);
  }
}

async function populateMaterialDropdowns() {
  try {
    // Load materials from existing supply chain system
    const companiesSnapshot = await db.collection('companies').get();
    const materialSelect = document.getElementById('transactionMaterial');
    
    if (materialSelect) {
      materialSelect.innerHTML = '<option value="">Select Material</option>';
      
      for (const companyDoc of companiesSnapshot.docs) {
        const companyData = companyDoc.data();
        
        try {
          const materialsSnapshot = await db.collection('companies')
            .doc(companyDoc.id)
            .collection('materials')
            .get();
          
          if (!materialsSnapshot.empty) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = companyData.name;
            
            materialsSnapshot.forEach(materialDoc => {
              const material = materialDoc.data();
              const option = document.createElement('option');
              option.value = materialDoc.id;
              option.textContent = material.name || 'Unnamed Material';
              option.setAttribute('data-company-id', companyDoc.id);
              option.setAttribute('data-company-name', companyData.name);
              option.setAttribute('data-price', material.pricePerBag || material.kgPerBag || 0);
              optgroup.appendChild(option);
            });
            
            materialSelect.appendChild(optgroup);
          }
        } catch (materialError) {
          console.warn(`Error loading materials for ${companyData.name}:`, materialError);
        }
      }
    }
  } catch (error) {
    console.error('Error populating material dropdown:', error);
  }
}

// Form handlers and validation
function initializeFormHandlers() {
  const transactionType = document.getElementById('transactionType');
  const paymentStatus = document.getElementById('paymentStatus');
  const transactionCompany = document.getElementById('transactionCompany');
  const transactionMaterial = document.getElementById('transactionMaterial');
  const transactionQuantity = document.getElementById('transactionQuantity');
  const transactionPrice = document.getElementById('transactionPrice');
  const transactionAmount = document.getElementById('transactionAmount');

  // Transaction type change handler
  if (transactionType) {
    transactionType.addEventListener('change', function() {
      const type = this.value;
      const materialGroup = document.getElementById('materialGroup');
      const quantityGroup = document.getElementById('quantityGroup');
      const priceGroup = document.getElementById('priceGroup');
      
      if (type === 'payment' || type === 'receipt') {
        // Hide material-related fields for pure payment transactions
        if (materialGroup) materialGroup.style.display = 'none';
        if (quantityGroup) quantityGroup.style.display = 'none';
        if (priceGroup) priceGroup.style.display = 'none';
      } else {
        // Show material fields for purchase/sale transactions
        if (materialGroup) materialGroup.style.display = 'block';
        if (quantityGroup) quantityGroup.style.display = 'block';
        if (priceGroup) priceGroup.style.display = 'block';
      }
    });
  }

  // Payment status change handler
  if (paymentStatus) {
    paymentStatus.addEventListener('change', function() {
      const paidAmountGroup = document.getElementById('paidAmountGroup');
      if (this.value === 'partial') {
        if (paidAmountGroup) paidAmountGroup.style.display = 'block';
      } else {
        if (paidAmountGroup) paidAmountGroup.style.display = 'none';
      }
    });
  }

  // Company selection handler
  if (transactionCompany && transactionMaterial) {
    transactionCompany.addEventListener('change', function() {
      const selectedCompanyId = this.value;
      const materialSelect = transactionMaterial;
      
      // Filter materials by selected company
      const allOptions = materialSelect.querySelectorAll('option');
      const optgroups = materialSelect.querySelectorAll('optgroup');
      
      // Reset material selection
      materialSelect.value = '';
      
      if (selectedCompanyId) {
        // Show only materials for selected company
        optgroups.forEach(optgroup => {
          const hasMatchingOptions = Array.from(optgroup.children).some(option => 
            option.getAttribute('data-company-id') === selectedCompanyId
          );
          optgroup.style.display = hasMatchingOptions ? 'block' : 'none';
        });
      } else {
        // Show all optgroups
        optgroups.forEach(optgroup => {
          optgroup.style.display = 'block';
        });
      }
    });
  }

  // Material selection handler
  if (transactionMaterial && transactionPrice) {
    transactionMaterial.addEventListener('change', function() {
      const selectedOption = this.options[this.selectedIndex];
      const price = selectedOption.getAttribute('data-price');
      const companyId = selectedOption.getAttribute('data-company-id');
      const companyName = selectedOption.getAttribute('data-company-name');
      
      if (price && price > 0) {
        transactionPrice.value = price;
      }
      
      // Auto-select company if not already selected
      if (companyId && transactionCompany && !transactionCompany.value) {
        transactionCompany.value = companyId;
      }
      
      calculateTotal();
    });
  }

  // Auto-calculate total amount
  function calculateTotal() {
    if (transactionQuantity && transactionPrice && transactionAmount) {
      const qty = parseFloat(transactionQuantity.value) || 0;
      const price = parseFloat(transactionPrice.value) || 0;
      const total = qty * price;
      transactionAmount.value = total.toFixed(2);
    }
  }

  if (transactionQuantity) {
    transactionQuantity.addEventListener('input', calculateTotal);
  }
  
  if (transactionPrice) {
    transactionPrice.addEventListener('input', calculateTotal);
  }

  // Make calculateTotal globally available
  window.calculateTotal = calculateTotal;
}

// Modal functions
function showAddTransactionModal() {
  populateCompanyDropdowns();
  populateMaterialDropdowns();
  showModal('transactionModal');
}

function showAddAccountModal() {
  showModal('accountModal');
}

// Transaction operations
async function saveTransaction() {
  const form = document.getElementById('transactionForm');
  if (!form.checkValidity()) {
    form.reportValidity();
    return;
  }

  showLoader();
  try {
    // Get form data
    const companyId = document.getElementById('transactionCompany').value;
    const materialSelect = document.getElementById('transactionMaterial');
    const selectedMaterialOption = materialSelect.options[materialSelect.selectedIndex];
    
    // Get company name
    const account = accountManager.accounts.get(companyId);
    const companyName = account ? account.name : 'Unknown Company';

    const transactionData = {
      companyId: companyId,
      companyName: companyName,
      type: document.getElementById('transactionType').value,
      materialId: materialSelect.value || null,
      materialName: selectedMaterialOption && selectedMaterialOption.value ? selectedMaterialOption.textContent : '',
      quantity: parseFloat(document.getElementById('transactionQuantity').value) || 0,
      unit: 'bags',
      pricePerUnit: parseFloat(document.getElementById('transactionPrice').value) || 0,
      totalAmount: parseFloat(document.getElementById('transactionAmount').value),
      paymentStatus: document.getElementById('paymentStatus').value,
      paidAmount: calculatePaidAmount(),
      paymentMethod: 'cash',
      notes: document.getElementById('transactionNotes').value || '',
      date: new Date()
    };

    function calculatePaidAmount() {
      const status = document.getElementById('paymentStatus').value;
      const totalAmount = parseFloat(document.getElementById('transactionAmount').value);
      const paidAmountInput = document.getElementById('paidAmount');
      
      if (status === 'paid') return totalAmount;
      if (status === 'partial' && paidAmountInput) return parseFloat(paidAmountInput.value) || 0;
      return 0;
    }

    // Create transaction
    await transactionManager.createTransaction(transactionData);

    // Reset form and close modal
    form.reset();
    hideModal('transactionModal');
    
    // Refresh data
    await loadDashboard();
    if (currentSection === 'transactions') await loadTransactions();
    if (currentSection === 'accounts') await loadAccounts();

    showNotification('Transaction saved successfully!', 'success');

  } catch (error) {
    console.error('Error saving transaction:', error);
    showNotification('Error saving transaction: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

async function saveAccount() {
  const form = document.getElementById('accountForm');
  if (!form.checkValidity()) {
    form.reportValidity();
    return;
  }

  showLoader();
  try {
    const accountData = {
      name: document.getElementById('accountName').value,
      type: document.getElementById('accountType').value,
      contactPerson: document.getElementById('contactPerson').value || '',
      phone: document.getElementById('accountPhone').value || '',
      address: document.getElementById('accountAddress').value || '',
      openingBalance: parseFloat(document.getElementById('openingBalance').value) || 0,
      creditLimit: 0,
      paymentTerms: 'immediate'
    };

    await accountManager.createAccount(accountData);

    // Reset form and close modal
    form.reset();
    hideModal('accountModal');
    
    // Refresh data
    await populateCompanyDropdowns();
    if (currentSection === 'accounts') await loadAccounts();
    
    showNotification('Account created successfully!', 'success');

  } catch (error) {
    console.error('Error saving account:', error);
    showNotification('Error saving account: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

// Payment operations
async function updatePayment(transactionId) {
  const transaction = transactionManager.transactions.find(t => t.id === transactionId);
  if (!transaction) {
    showNotification('Transaction not found', 'error');
    return;
  }

  const pendingAmount = transaction.pendingAmount || 0;
  if (pendingAmount <= 0) {
    showNotification('No pending amount for this transaction', 'info');
    return;
  }

  const paymentAmount = prompt(
    `Pending Amount: ${formatCurrency(pendingAmount)}\n\nEnter payment amount:`, 
    pendingAmount.toString()
  );

  if (!paymentAmount || isNaN(paymentAmount) || parseFloat(paymentAmount) <= 0) {
    return;
  }

  const amount = parseFloat(paymentAmount);
  if (amount > pendingAmount) {
    showNotification('Payment amount cannot exceed pending amount', 'error');
    return;
  }

  showLoader();
  try {
    const paymentData = {
      amount: amount,
      method: 'cash',
      reference: '',
      date: new Date(),
      notes: `Payment recorded via dashboard`
    };

    await transactionManager.updatePaymentStatus(transactionId, paymentData);

    // Refresh data
    await loadDashboard();
    if (currentSection === 'transactions') await loadTransactions();
    if (currentSection === 'accounts') await loadAccounts();

    showNotification('Payment recorded successfully!', 'success');

  } catch (error) {
    console.error('Error updating payment:', error);
    showNotification('Error recording payment: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

async function recordPayment(accountId) {
  const account = accountManager.accounts.get(accountId);
  if (!account) {
    showNotification('Account not found', 'error');
    return;
  }

  const outstandingAmount = account.outstandingReceivable || 0;
  if (outstandingAmount <= 0) {
    showNotification('No outstanding receivable for this account', 'info');
    return;
  }

  const paymentAmount = prompt(
    `Outstanding Receivable: ${formatCurrency(outstandingAmount)}\n\nEnter payment received:`,
    outstandingAmount.toString()
  );

  if (!paymentAmount || isNaN(paymentAmount) || parseFloat(paymentAmount) <= 0) {
    return;
  }

  const amount = parseFloat(paymentAmount);
  if (amount > outstandingAmount) {
    showNotification('Payment amount cannot exceed outstanding receivable', 'error');
    return;
  }

  showLoader();
  try {
    // Create a receipt transaction
    const transactionData = {
      companyId: accountId,
      companyName: account.name,
      type: 'receipt',
      totalAmount: amount,
      paymentStatus: 'paid',
      paidAmount: amount,
      paymentMethod: 'cash',
      notes: 'Payment received via dashboard',
      date: new Date()
    };

    await transactionManager.createTransaction(transactionData);

    // Refresh data
    await loadDashboard();
    if (currentSection === 'accounts') await loadAccounts();

    showNotification('Payment recorded successfully!', 'success');

  } catch (error) {
    console.error('Error recording payment:', error);
    showNotification('Error recording payment: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

// View functions
async function viewTransactionDetails(transactionId) {
  showLoader();
  try {
    const doc = await db.collection('ledger_transactions').doc(transactionId).get();
    if (!doc.exists) {
      showNotification('Transaction not found', 'error');
      return;
    }

    const transaction = { id: doc.id, ...doc.data() };
    const account = accountManager.accounts.get(transaction.companyId);
    const companyName = account ? account.name : transaction.companyName || 'Unknown';

    // Get payment history
    const paymentHistory = await transactionManager.getPaymentHistory(transactionId);

    let detailsHtml = `
      <div class="transaction-details">
        <div class="grid grid-cols-2 gap-4 mb-4">
          <div>
            <h4 class="font-semibold text-gray-700">Transaction Details</h4>
            <p><strong>Transaction #:</strong> ${transaction.transactionNumber || transactionId.substr(0, 8)}</p>
            <p><strong>Company:</strong> ${companyName}</p>
            <p><strong>Type:</strong> ${transaction.type.toUpperCase()}</p>
            <p><strong>Date:</strong> ${formatDate(transaction.createdAt)}</p>
            <p><strong>Status:</strong> ${transaction.paymentStatus.toUpperCase()}</p>
          </div>
          <div>
            <h4 class="font-semibold text-gray-700">Financial Summary</h4>
            <p><strong>Total Amount:</strong> ${formatCurrency(transaction.totalAmount)}</p>
            <p><strong>Paid Amount:</strong> ${formatCurrency(transaction.paidAmount || 0)}</p>
            <p><strong>Pending:</strong> ${formatCurrency(transaction.pendingAmount || 0)}</p>
          </div>
        </div>
    `;

    if (transaction.materialName) {
      detailsHtml += `
        <div class="mb-4">
          <h4 class="font-semibold text-gray-700">Material Details</h4>
          <p><strong>Material:</strong> ${transaction.materialName}</p>
          <p><strong>Quantity:</strong> ${transaction.quantity} ${transaction.unit}</p>
          <p><strong>Price per Unit:</strong> ${formatCurrency(transaction.pricePerUnit || 0)}</p>
        </div>
      `;
    }

    if (paymentHistory.length > 0) {
      detailsHtml += `
        <div class="mb-4">
          <h4 class="font-semibold text-gray-700">Payment History</h4>
          <div class="overflow-x-auto">
            <table class="table">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Amount</th>
                  <th>Method</th>
                  <th>Reference</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
      `;

      paymentHistory.forEach(payment => {
        detailsHtml += `
          <tr>
            <td>${formatDate(payment.date)}</td>
            <td class="font-medium">${formatCurrency(payment.amount)}</td>
            <td>${payment.method}</td>
            <td>${payment.reference || '-'}</td>
            <td>${payment.notes || '-'}</td>
          </tr>
        `;
      });

      detailsHtml += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    }

    if (transaction.notes) {
      detailsHtml += `
        <div class="mb-4">
          <h4 class="font-semibold text-gray-700">Notes</h4>
          <p>${transaction.notes}</p>
        </div>
      `;
    }

    detailsHtml += '</div>';

    // Show in a modal
    const modalHtml = `
      <div id="transactionDetailsModal" class="modal-backdrop">
        <div class="modal">
          <div class="modal-header">
            <h3 class="modal-title">Transaction Details</h3>
            <button onclick="hideModal('transactionDetailsModal')" class="btn btn-secondary btn-sm">✕</button>
          </div>
          <div class="modal-content">
            ${detailsHtml}
          </div>
          <div class="modal-footer">
            ${transaction.pendingAmount > 0 ? `<button class="btn btn-primary" onclick="hideModal('transactionDetailsModal'); updatePayment('${transactionId}')">Record Payment</button>` : ''}
            <button class="btn btn-secondary" onclick="hideModal('transactionDetailsModal')">Close</button>
          </div>
        </div>
      </div>
    `;

    // Remove existing modal if any
    const existingModal = document.getElementById('transactionDetailsModal');
    if (existingModal) existingModal.remove();

    // Add new modal
    document.body.insertAdjacentHTML('beforeend', modalHtml);

  } catch (error) {
    console.error('Error loading transaction details:', error);
    showNotification('Error loading transaction details: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

async function viewAccountLedger(accountId) {
  showLoader();
  try {
    const account = accountManager.accounts.get(accountId);
    if (!account) {
      showNotification('Account not found', 'error');
      return;
    }

    // Get all transactions for this account
    const transactionHistory = await transactionManager.getTransactionHistory(accountId);

    let ledgerHtml = `
      <div class="account-ledger">
        <div class="mb-4">
          <h4 class="font-semibold text-gray-700">Account Summary</h4>
          <div class="grid grid-cols-2 gap-4">
            <div>
              <p><strong>Company:</strong> ${account.name}</p>
              <p><strong>Type:</strong> ${account.type}</p>
              <p><strong>Contact:</strong> ${account.contactPerson} ${account.phone}</p>
            </div>
            <div>
              <p><strong>Current Balance:</strong> ${formatCurrency(account.currentBalance || 0)}</p>
              <p><strong>Outstanding Receivable:</strong> ${formatCurrency(account.outstandingReceivable || 0)}</p>
              <p><strong>Outstanding Payable:</strong> ${formatCurrency(account.outstandingPayable || 0)}</p>
            </div>
          </div>
        </div>
        
        <div>
          <h4 class="font-semibold text-gray-700 mb-3">Transaction History</h4>
    `;

    if (transactionHistory.length === 0) {
      ledgerHtml += '<p class="text-center text-gray-500 py-4">No transactions found</p>';
    } else {
      ledgerHtml += `
        <div class="overflow-x-auto">
          <table class="table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Type</th>
                <th>Description</th>
                <th>Debit</th>
                <th>Credit</th>
                <th>Balance</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
      `;

      let runningBalance = account.openingBalance || 0;
      
      transactionHistory.forEach(transaction => {
        const isDebit = transaction.type === 'sale' || transaction.type === 'payment';
        const amount = transaction.netAmount || transaction.totalAmount;
        
        if (isDebit) {
          runningBalance += amount;
        } else {
          runningBalance -= amount;
        }

        const description = transaction.materialName ? 
          `${transaction.materialName} (${transaction.quantity} ${transaction.unit})` :
          transaction.notes || transaction.type.toUpperCase();

        ledgerHtml += `
          <tr>
            <td>${formatDate(transaction.createdAt)}</td>
            <td>${getTransactionIcon(transaction.type)} ${transaction.type.toUpperCase()}</td>
            <td>${description}</td>
            <td class="text-right">${isDebit ? formatCurrency(amount) : '-'}</td>
            <td class="text-right">${!isDebit ? formatCurrency(amount) : '-'}</td>
            <td class="text-right font-medium ${runningBalance >= 0 ? 'positive' : 'negative'}">${formatCurrency(Math.abs(runningBalance))}</td>
            <td>
              <span class="badge ${transaction.paymentStatus === 'paid' ? 'badge-success' : 
                                 transaction.paymentStatus === 'partial' ? 'badge-warning' : 'badge-danger'}">
                ${transaction.paymentStatus.toUpperCase()}
              </span>
            </td>
          </tr>
        `;
      });

      ledgerHtml += `
            </tbody>
          </table>
        </div>
      `;
    }

    ledgerHtml += `
        </div>
      </div>
    `;

    // Show in modal
    const modalHtml = `
      <div id="accountLedgerModal" class="modal-backdrop">
        <div class="modal" style="max-width: 90vw;">
          <div class="modal-header">
            <h3 class="modal-title">Account Ledger - ${account.name}</h3>
            <button onclick="hideModal('accountLedgerModal')" class="btn btn-secondary btn-sm">✕</button>
          </div>
          <div class="modal-content">
            ${ledgerHtml}
          </div>
          <div class="modal-footer">
            <button class="btn btn-primary" onclick="hideModal('accountLedgerModal'); recordPayment('${accountId}')">Record Payment</button>
            <button class="btn btn-secondary" onclick="hideModal('accountLedgerModal')">Close</button>
          </div>
        </div>
      </div>
    `;

    // Remove existing modal if any
    const existingModal = document.getElementById('accountLedgerModal');
    if (existingModal) existingModal.remove();

    // Add new modal
    document.body.insertAdjacentHTML('beforeend', modalHtml);

  } catch (error) {
    console.error('Error loading account ledger:', error);
    showNotification('Error loading account ledger: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

// Notification system
function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
    color: white;
    padding: 1rem 1.5rem;
    border-radius: 0.5rem;
    box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
    z-index: 10000;
    max-width: 400px;
    animation: slideIn 0.3s ease-out;
  `;
  
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 5000);
}

// Add CSS animations
const style = document.createElement('style');
style.textContent = `
  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
`;
document.head.appendChild(style);

// Delete operations
async function deleteTransaction(transactionId) {
  if (!confirm('Are you sure you want to delete this transaction? This action cannot be undone.')) {
    return;
  }

  showLoader();
  try {
    // Get transaction details first to reverse account balances
    const doc = await db.collection('ledger_transactions').doc(transactionId).get();
    if (!doc.exists) {
      showNotification('Transaction not found', 'error');
      return;
    }

    const transaction = doc.data();
    
    // Reverse account balance
    await accountManager.updateAccountBalance(
      transaction.companyId,
      transaction.type,
      transaction.netAmount || transaction.totalAmount,
      'subtract'
    );

    // If there were payments, reverse those too
    if (transaction.paidAmount > 0) {
      const paymentType = transaction.type === 'sale' ? 'receipt' : 'payment';
      await accountManager.updateAccountBalance(
        transaction.companyId,
        paymentType,
        transaction.paidAmount,
        'subtract'
      );
    }

    // Delete payment history
    const paymentHistorySnapshot = await db.collection('payment_history')
      .where('transactionId', '==', transactionId)
      .get();
    
    const batch = db.batch();
    paymentHistorySnapshot.forEach(doc => {
      batch.delete(doc.ref);
    });
    
    // Delete the transaction
    batch.delete(db.collection('ledger_transactions').doc(transactionId));
    
    await batch.commit();

    // Refresh data
    await loadDashboard();
    if (currentSection === 'transactions') await loadTransactions();
    if (currentSection === 'accounts') await loadAccounts();

    showNotification('Transaction deleted successfully!', 'success');

  } catch (error) {
    console.error('Error deleting transaction:', error);
    showNotification('Error deleting transaction: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

async function deleteAccount(accountId) {
  const account = accountManager.accounts.get(accountId);
  if (!account) {
    showNotification('Account not found', 'error');
    return;
  }

  if (!confirm(`Are you sure you want to delete "${account.name}"? This will also delete all related transactions and cannot be undone.`)) {
    return;
  }

  showLoader();
  try {
    // Get all transactions for this account
    const transactionsSnapshot = await db.collection('ledger_transactions')
      .where('companyId', '==', accountId)
      .get();

    const batch = db.batch();
    
    // Delete all payment history for transactions of this account
    for (const transactionDoc of transactionsSnapshot.docs) {
      const paymentHistorySnapshot = await db.collection('payment_history')
        .where('transactionId', '==', transactionDoc.id)
        .get();
      
      paymentHistorySnapshot.forEach(paymentDoc => {
        batch.delete(paymentDoc.ref);
      });
      
      // Delete the transaction
      batch.delete(transactionDoc.ref);
    }
    
    // Delete the account
    batch.delete(db.collection('ledger_accounts').doc(accountId));
    
    await batch.commit();

    // Remove from local cache
    accountManager.accounts.delete(accountId);

    // Refresh data
    await populateCompanyDropdowns();
    if (currentSection === 'accounts') await loadAccounts();
    await loadDashboard();

    showNotification('Account and all related data deleted successfully!', 'success');

  } catch (error) {
    console.error('Error deleting account:', error);
    showNotification('Error deleting account: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

// Edit operations (placeholder functions)
function editAccount(accountId) {
  showNotification('Edit account functionality will be implemented in next update', 'info');
}

function editTransaction(transactionId) {
  showNotification('Edit transaction functionality will be implemented in next update', 'info');
}

// Search and filter functions
function initializeSearchAndFilter() {
  const accountSearch = document.getElementById('accountSearch');
  const transactionSearch = document.getElementById('transactionSearch');
  
  if (accountSearch) {
    accountSearch.addEventListener('input', function() {
      const searchTerm = this.value.toLowerCase();
      const rows = document.querySelectorAll('#accountsTableBody tr');
      
      rows.forEach(row => {
        const companyName = row.cells[0].textContent.toLowerCase();
        const contactInfo = row.cells[0].querySelector('.text-xs')?.textContent.toLowerCase() || '';
        
        if (companyName.includes(searchTerm) || contactInfo.includes(searchTerm)) {
          row.style.display = '';
        } else {
          row.style.display = 'none';
        }
      });
    });
  }
  
  if (transactionSearch) {
    transactionSearch.addEventListener('input', function() {
      const searchTerm = this.value.toLowerCase();
      const rows = document.querySelectorAll('#transactionsTableBody tr');
      
      rows.forEach(row => {
        const companyName = row.cells[1].textContent.toLowerCase();
        const materialName = row.cells[3].textContent.toLowerCase();
        const transactionNumber = row.cells[0].querySelector('.text-xs')?.textContent.toLowerCase() || '';
        
        if (companyName.includes(searchTerm) || 
            materialName.includes(searchTerm) || 
            transactionNumber.includes(searchTerm)) {
          row.style.display = '';
        } else {
          row.style.display = 'none';
        }
      });
    });
  }
}

// Filter functionality for transactions
function applyFilters() {
  const typeFilter = document.getElementById('transactionTypeFilter')?.value || '';
  const statusFilter = document.getElementById('paymentStatusFilter')?.value || '';
  const fromDate = document.getElementById('fromDate')?.value || '';
  const toDate = document.getElementById('toDate')?.value || '';
  
  const rows = document.querySelectorAll('#transactionsTableBody tr');
  
  rows.forEach(row => {
    let show = true;
    
    // Type filter
    if (typeFilter) {
      const typeText = row.cells[2].textContent.toLowerCase();
      if (!typeText.includes(typeFilter.toLowerCase())) {
        show = false;
      }
    }
    
    // Status filter  
    if (statusFilter) {
      const statusText = row.cells[6].textContent.toLowerCase();
      if (!statusText.includes(statusFilter.toLowerCase())) {
        show = false;
      }
    }
    
    // Date filters would require more complex logic with actual transaction data
    // For now, we'll implement basic filtering
    
    row.style.display = show ? '' : 'none';
  });
  
  showNotification('Filters applied successfully', 'success');
}

function clearFilters() {
  const filters = [
    'transactionTypeFilter',
    'paymentStatusFilter', 
    'fromDate',
    'toDate'
  ];
  
  filters.forEach(filterId => {
    const element = document.getElementById(filterId);
    if (element) element.value = '';
  });
  
  const rows = document.querySelectorAll('#transactionsTableBody tr');
  rows.forEach(row => {
    row.style.display = '';
  });
  
  showNotification('Filters cleared', 'info');
}

// Reports functionality
function loadReports() {
  initializeCharts();
}

function initializeCharts() {
  // Wait for Chart.js to be available
  if (typeof Chart === 'undefined') {
    setTimeout(initializeCharts, 100);
    return;
  }

  // Profit & Loss Chart
  const plCtx = document.getElementById('profitLossChart');
  if (plCtx) {
    // Calculate monthly data from transactions
    const monthlyData = calculateMonthlyProfitLoss();
    
    new Chart(plCtx, {
      type: 'line',
      data: {
        labels: monthlyData.labels,
        datasets: [{
          label: 'Sales',
          data: monthlyData.sales,
          borderColor: '#10b981',
          backgroundColor: 'rgba(16, 185, 129, 0.1)',
          tension: 0.4,
          fill: true
        }, {
          label: 'Purchases',
          data: monthlyData.purchases,
          borderColor: '#ef4444',
          backgroundColor: 'rgba(239, 68, 68, 0.1)',
          tension: 0.4,
          fill: true
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'top',
          },
          title: {
            display: true,
            text: 'Monthly Profit & Loss Trend'
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              callback: function(value) {
                return '₹' + value.toLocaleString();
              }
            }
          }
        },
        interaction: {
          intersect: false,
          mode: 'index'
        }
      }
    });
  }

  // Outstanding Analysis Chart
  const outCtx = document.getElementById('outstandingChart');
  if (outCtx) {
    const outstandingData = calculateOutstandingAnalysis();
    
    new Chart(outCtx, {
      type: 'doughnut',
      data: {
        labels: ['Receivables', 'Payables', 'Net Cash Flow'],
        datasets: [{
          data: [
            outstandingData.receivables,
            outstandingData.payables,
            Math.max(0, outstandingData.receivables - outstandingData.payables)
          ],
          backgroundColor: ['#f59e0b', '#ef4444', '#10b981'],
          borderWidth: 2,
          borderColor: '#ffffff'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
          },
          title: {
            display: true,
            text: 'Outstanding Analysis'
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                const value = context.parsed;
                return context.label + ': ₹' + value.toLocaleString();
              }
            }
          }
        }
      }
    });
  }
}

function calculateMonthlyProfitLoss() {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
  const sales = [0, 0, 0, 0, 0, 0];
  const purchases = [0, 0, 0, 0, 0, 0];
  
  // This would be calculated from actual transaction data
  // For demo purposes, using sample data
  transactionManager.transactions.forEach(transaction => {
    const date = new Date(transaction.createdAt?.toDate ? transaction.createdAt.toDate() : transaction.createdAt);
    const monthIndex = date.getMonth();
    
    if (monthIndex < 6) {
      if (transaction.type === 'sale') {
        sales[monthIndex] += transaction.netAmount || transaction.totalAmount || 0;
      } else if (transaction.type === 'purchase') {
        purchases[monthIndex] += transaction.netAmount || transaction.totalAmount || 0;
      }
    }
  });
  
  return {
    labels: months,
    sales: sales,
    purchases: purchases
  };
}

function calculateOutstandingAnalysis() {
  let receivables = 0;
  let payables = 0;
  
  accountManager.accounts.forEach(account => {
    receivables += account.outstandingReceivable || 0;
    payables += account.outstandingPayable || 0;
  });
  
  return {
    receivables: receivables,
    payables: payables
  };
}

// Report generation functions
function generateReport(type) {
  showLoader();
  
  setTimeout(() => {
    hideLoader();
    
    switch (type) {
      case 'aging':
        generateAgingReport();
        break;
      case 'pl':
        generatePLStatement();
        break;
      case 'ledger':
        generateLedgerSummary();
        break;
      default:
        showNotification('Unknown report type', 'error');
    }
  }, 1000);
}

function generateAgingReport() {
  const agingData = [];
  
  accountManager.accounts.forEach(account => {
    if (account.outstandingReceivable > 0) {
      agingData.push({
        company: account.name,
        amount: account.outstandingReceivable,
        // This would calculate actual aging based on transaction dates
        days: Math.floor(Math.random() * 90) + 1
      });
    }
  });
  
  let reportHtml = `
    <div class="aging-report">
      <h3 class="text-xl font-bold mb-4">Accounts Receivable Aging Report</h3>
      <p class="text-sm text-gray-600 mb-4">Generated on: ${new Date().toLocaleDateString('en-IN')}</p>
      
      <div class="overflow-x-auto">
        <table class="table">
          <thead>
            <tr>
              <th>Company Name</th>
              <th>Outstanding Amount</th>
              <th>Days Outstanding</th>
              <th>Category</th>
            </tr>
          </thead>
          <tbody>
  `;
  
  agingData.forEach(item => {
    const category = item.days <= 30 ? 'Current' : 
                    item.days <= 60 ? '31-60 Days' :
                    item.days <= 90 ? '61-90 Days' : '90+ Days';
    const categoryClass = item.days <= 30 ? 'badge-success' :
                         item.days <= 60 ? 'badge-warning' :
                         'badge-danger';
    
    reportHtml += `
      <tr>
        <td class="font-medium">${item.company}</td>
        <td class="text-right">${formatCurrency(item.amount)}</td>
        <td class="text-center">${item.days}</td>
        <td><span class="badge ${categoryClass}">${category}</span></td>
      </tr>
    `;
  });
  
  reportHtml += `
          </tbody>
        </table>
      </div>
      
      <div class="mt-6 text-right">
        <p class="text-lg font-semibold">Total Outstanding: ${formatCurrency(agingData.reduce((sum, item) => sum + item.amount, 0))}</p>
      </div>
    </div>
  `;
  
  showReportModal('Aging Report', reportHtml);
}

function generatePLStatement() {
  let totalSales = 0;
  let totalPurchases = 0;
  let totalReceipts = 0;
  let totalPayments = 0;
  
  transactionManager.transactions.forEach(transaction => {
    const amount = transaction.netAmount || transaction.totalAmount || 0;
    switch (transaction.type) {
      case 'sale':
        totalSales += amount;
        break;
      case 'purchase':
        totalPurchases += amount;
        break;
      case 'receipt':
        totalReceipts += amount;
        break;
      case 'payment':
        totalPayments += amount;
        break;
    }
  });
  
  const grossProfit = totalSales - totalPurchases;
  const netCashFlow = totalReceipts - totalPayments;
  
  const reportHtml = `
    <div class="pl-statement">
      <h3 class="text-xl font-bold mb-4">Profit & Loss Statement</h3>
      <p class="text-sm text-gray-600 mb-6">For the period: ${new Date(new Date().getFullYear(), 0, 1).toLocaleDateString('en-IN')} to ${new Date().toLocaleDateString('en-IN')}</p>
      
      <div class="space-y-4">
        <div class="border-b pb-4">
          <h4 class="font-semibold text-lg text-green-600">Revenue</h4>
          <div class="flex justify-between">
            <span>Total Sales</span>
            <span class="font-medium">${formatCurrency(totalSales)}</span>
          </div>
        </div>
        
        <div class="border-b pb-4">
          <h4 class="font-semibold text-lg text-red-600">Costs</h4>
          <div class="flex justify-between">
            <span>Total Purchases</span>
            <span class="font-medium">${formatCurrency(totalPurchases)}</span>
          </div>
        </div>
        
        <div class="border-b pb-4">
          <div class="flex justify-between text-lg font-bold">
            <span>Gross Profit</span>
            <span class="${grossProfit >= 0 ? 'text-green-600' : 'text-red-600'}">${formatCurrency(grossProfit)}</span>
          </div>
          <div class="text-sm text-gray-600">
            Margin: ${totalSales > 0 ? ((grossProfit / totalSales) * 100).toFixed(2) : 0}%
          </div>
        </div>
        
        <div class="bg-gray-50 p-4 rounded">
          <h4 class="font-semibold text-lg mb-2">Cash Flow Analysis</h4>
          <div class="flex justify-between mb-2">
            <span>Total Receipts</span>
            <span class="font-medium text-green-600">${formatCurrency(totalReceipts)}</span>
          </div>
          <div class="flex justify-between mb-2">
            <span>Total Payments</span>
            <span class="font-medium text-red-600">${formatCurrency(totalPayments)}</span>
          </div>
          <div class="flex justify-between font-bold text-lg border-t pt-2">
            <span>Net Cash Flow</span>
            <span class="${netCashFlow >= 0 ? 'text-green-600' : 'text-red-600'}">${formatCurrency(netCashFlow)}</span>
          </div>
        </div>
      </div>
    </div>
  `;
  
  showReportModal('Profit & Loss Statement', reportHtml);
}

function generateLedgerSummary() {
  let reportHtml = `
    <div class="ledger-summary">
      <h3 class="text-xl font-bold mb-4">Ledger Summary Report</h3>
      <p class="text-sm text-gray-600 mb-6">Generated on: ${new Date().toLocaleDateString('en-IN')}</p>
      
      <div class="overflow-x-auto">
        <table class="table">
          <thead>
            <tr>
              <th>Company Name</th>
              <th>Type</th>
              <th>Total Sales</th>
              <th>Total Purchases</th>
              <th>Outstanding Receivable</th>
              <th>Outstanding Payable</th>
              <th>Net Balance</th>
            </tr>
          </thead>
          <tbody>
  `;
  
  accountManager.accounts.forEach(account => {
    const netBalance = (account.outstandingReceivable || 0) - (account.outstandingPayable || 0);
    const balanceClass = netBalance > 0 ? 'text-green-600' : netBalance < 0 ? 'text-red-600' : '';
    
    reportHtml += `
      <tr>
        <td class="font-medium">${account.name}</td>
        <td><span class="badge badge-secondary">${account.type}</span></td>
        <td class="text-right">${formatCurrency(account.totalSales || 0)}</td>
        <td class="text-right">${formatCurrency(account.totalPurchases || 0)}</td>
        <td class="text-right">${formatCurrency(account.outstandingReceivable || 0)}</td>
        <td class="text-right">${formatCurrency(account.outstandingPayable || 0)}</td>
        <td class="text-right font-medium ${balanceClass}">${formatCurrency(Math.abs(netBalance))}</td>
      </tr>
    `;
  });
  
  reportHtml += `
          </tbody>
        </table>
      </div>
    </div>
  `;
  
  showReportModal('Ledger Summary', reportHtml);
}

function showReportModal(title, content) {
  const modalHtml = `
    <div id="reportModal" class="modal-backdrop">
      <div class="modal" style="max-width: 90vw;">
        <div class="modal-header">
          <h3 class="modal-title">${title}</h3>
          <button onclick="hideModal('reportModal')" class="btn btn-secondary btn-sm">✕</button>
        </div>
        <div class="modal-content">
          ${content}
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" onclick="printReport()">Print Report</button>
          <button class="btn btn-secondary" onclick="exportReport()">Export PDF</button>
          <button class="btn btn-secondary" onclick="hideModal('reportModal')">Close</button>
        </div>
      </div>
    </div>
  `;
  
  // Remove existing modal
  const existingModal = document.getElementById('reportModal');
  if (existingModal) existingModal.remove();
  
  // Add new modal
  document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function printReport() {
  const reportContent = document.querySelector('#reportModal .modal-content').innerHTML;
  const printWindow = window.open('', '_blank');
  printWindow.document.write(`
    <html>
      <head>
        <title>Report - Aditya Fertilizers</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .table { width: 100%; border-collapse: collapse; margin: 20px 0; }
          .table th, .table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          .table th { background-color: #f2f2f2; font-weight: bold; }
          .text-right { text-align: right; }
          .text-center { text-align: center; }
          .font-bold { font-weight: bold; }
          .text-green-600 { color: #059669; }
          .text-red-600 { color: #dc2626; }
          .badge { padding: 2px 8px; border-radius: 12px; font-size: 12px; }
          .badge-secondary { background-color: #f1f5f9; color: #64748b; }
          .badge-success { background-color: #dcfce7; color: #059669; }
          .badge-warning { background-color: #fef3c7; color: #d97706; }
          .badge-danger { background-color: #fecaca; color: #dc2626; }
        </style>
      </head>
      <body>
        <div style="text-align: center; margin-bottom: 30px;">
          <h1>Aditya Fertilizers</h1>
          <p>Professional Accounting Ledger System</p>
        </div>
        ${reportContent}
        <div style="margin-top: 30px; text-align: right; font-size: 12px; color: #666;">
          Generated on: ${new Date().toLocaleDateString('en-IN')} ${new Date().toLocaleTimeString('en-IN')}
        </div>
      </body>
    </html>
  `);
  printWindow.document.close();
  printWindow.print();
}

function exportReport() {
  showNotification('PDF export functionality will be implemented in next update', 'info');
}

// Settings functions
function syncWithSupplyChain() {
  if (!confirm('This will sync all data from the supply chain system. This may take several minutes. Continue?')) {
    return;
  }
  
  showLoader();
  loadExistingData().then(() => {
    showNotification('Sync completed successfully!', 'success');
  }).catch(error => {
    console.error('Sync failed:', error);
    showNotification('Sync failed: ' + error.message, 'error');
  });
}

function exportData() {
  showLoader();
  
  // Simulate data export
  setTimeout(() => {
    hideLoader();
    showNotification('Data export functionality will be implemented in next update. This will export all ledger data to Excel format.', 'info');
  }, 2000);
}

function clearCache() {
  if (!confirm('This will clear all cached data and refresh the application. Continue?')) {
    return;
  }
  
  showLoader();
  
  // Clear local data
  accountManager.accounts.clear();
  transactionManager.transactions = [];
  materials = [];
  
  // Reload data
  loadExistingData().then(() => {
    showNotification('Cache cleared and data reloaded successfully!', 'success');
  }).catch(error => {
    console.error('Error reloading data:', error);
    showNotification('Error reloading data: ' + error.message, 'error');
  });
}

function resetSystem() {
  if (!confirm('WARNING: This will delete ALL ledger data permanently. This action CANNOT be undone!')) {
    return;
  }
  
  const confirmReset = prompt('Type "RESET LEDGER SYSTEM" to confirm complete system reset:');
  if (confirmReset !== 'RESET LEDGER SYSTEM') {
    showNotification('System reset cancelled', 'info');
    return;
  }
  
  const finalConfirm = confirm('This is your FINAL WARNING. All data will be permanently lost. Are you absolutely sure?');
  if (!finalConfirm) {
    showNotification('System reset cancelled', 'info');
    return;
  }
  
  showLoader();
  
  // This would implement actual system reset
  setTimeout(() => {
    hideLoader();
    showNotification('System reset functionality requires additional security measures and will be implemented with proper safeguards in production version', 'error');
  }, 2000);
}

// Data import from existing supply chain system
async function loadExistingData() {
  showLoader();
  try {
    console.log('Loading existing supply chain data...');
    
    // Clear existing data
    accountManager.accounts.clear();
    transactionManager.transactions = [];
    materials = [];

    // Load companies and create accounts
    const companiesSnapshot = await db.collection('companies').get();
    console.log(`Found ${companiesSnapshot.size} companies in supply chain`);

    for (const companyDoc of companiesSnapshot.docs) {
      const companyData = companyDoc.data();
      
      // Create account for this company
      try {
        await accountManager.createAccount({
          id: companyDoc.id,
          name: companyData.name,
          type: 'both', // Default to both customer and supplier
          contactPerson: companyData.contactPerson || '',
          phone: companyData.phone || '',
          address: companyData.address || '',
          openingBalance: 0
        });
        console.log(`Created account for: ${companyData.name}`);
      } catch (accountError) {
        console.warn(`Error creating account for ${companyData.name}:`, accountError);
      }

      // Load materials
      try {
        const materialsSnapshot = await db.collection('companies')
          .doc(companyDoc.id)
          .collection('materials')
          .get();

        materialsSnapshot.forEach(materialDoc => {
          const materialData = materialDoc.data();
          materials.push({
            id: materialDoc.id,
            companyId: companyDoc.id,
            companyName: companyData.name,
            name: materialData.name || 'Unnamed Material',
            pricePerBag: materialData.pricePerBag || materialData.kgPerBag || 0,
            ...materialData
          });
        });
        console.log(`Loaded ${materialsSnapshot.size} materials for ${companyData.name}`);
      } catch (materialError) {
        console.warn(`Error loading materials for ${companyData.name}:`, materialError);
      }

      // Load and convert entries to transactions
      try {
        const entriesSnapshot = await db.collection('companies')
          .doc(companyDoc.id)
          .collection('entries')
          .orderBy('createdAt', 'desc')
          .limit(50) // Limit to recent entries
          .get();

        for (const entryDoc of entriesSnapshot.docs) {
          const entryData = entryDoc.data();
          
          // Check if already converted
          const existingTransaction = await db.collection('ledger_transactions')
            .where('companyId', '==', companyDoc.id)
            .where('originalEntryId', '==', entryDoc.id)
            .get();

          if (existingTransaction.empty) {
            try {
              // Convert entry to transaction
              const material = materials.find(m => 
                m.id === entryData.materialId && m.companyId === companyDoc.id
              );

              const transactionData = {
                companyId: companyDoc.id,
                companyName: companyData.name,
                type: entryData.type || 'purchase',
                materialId: entryData.materialId || null,
                materialName: material ? material.name : 'Unknown Material',
                quantity: entryData.bags || 0,
                unit: 'bags',
                pricePerUnit: entryData.pricePerBag || entryData.rate || 0,
                totalAmount: entryData.totalValue || 0,
                paymentStatus: entryData.paymentStatus || 'pending',
                paidAmount: entryData.paidAmount || 0,
                notes: entryData.note || entryData.notes || '',
                party: entryData.party || '',
                date: entryData.createdAt || new Date(),
                originalEntryId: entryDoc.id
              };

              await transactionManager.createTransaction(transactionData);
              console.log(`Converted entry to transaction: ${material ? material.name : 'Unknown'} - ${formatCurrency(entryData.totalValue || 0)}`);
              
            } catch (transactionError) {
              console.warn(`Error converting entry ${entryDoc.id}:`, transactionError);
            }
          }
        }
        console.log(`Processed ${entriesSnapshot.size} entries for ${companyData.name}`);
      } catch (entryError) {
        console.warn(`Error loading entries for ${companyData.name}:`, entryError);
      }
    }

    console.log(`Data loading complete: ${accountManager.accounts.size} accounts, ${materials.length} materials, ${transactionManager.transactions.length} transactions`);

    // Populate dropdowns and load dashboard
    await populateCompanyDropdowns();
    populateMaterialDropdowns();
    await loadDashboard();

    showNotification('Data loaded successfully from supply chain system!', 'success');

  } catch (error) {
    console.error('Error loading existing data:', error);
    showNotification('Error loading data: ' + error.message, 'error');
    throw error;
  } finally {
    hideLoader();
  }
}

// Initialize application
async function initializeApp() {
  showLoader();
  try {
    console.log('Initializing Aditya Fertilizers Ledger System...');
    
    // Authenticate
    await autoSignIn();
    console.log('Authentication successful');
    
    // Initialize form handlers
    initializeFormHandlers();
    
    // Initialize search and filter functionality
    initializeSearchAndFilter();
    
    // Set up navigation
    document.querySelectorAll('.nav-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        showSection(btn.dataset.section);
      });
    });
    
    // Load existing data
    await loadExistingData();
    
    console.log('Application initialized successfully');
    
  } catch (error) {
    console.error('Error initializing application:', error);
    showNotification('Error initializing application: ' + error.message, 'error');
  } finally {
    hideLoader();
  }
}

// Start application when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, starting application...');
  initializeApp();
});

// Global error handling
window.addEventListener('error', function(e) {
  console.error('Global error:', e.error);
  showNotification('An unexpected error occurred. Please refresh the page.', 'error');
});

window.addEventListener('unhandledrejection', function(e) {
  console.error('Unhandled promise rejection:', e.reason);
  showNotification('An unexpected error occurred. Please try again.', 'error');
});

// Export functions for global access
window.showAddTransactionModal = showAddTransactionModal;
window.showAddAccountModal = showAddAccountModal;
window.saveTransaction = saveTransaction;
window.saveAccount = saveAccount;
window.updatePayment = updatePayment;
window.recordPayment = recordPayment;
window.viewTransactionDetails = viewTransactionDetails;
window.viewAccountLedger = viewAccountLedger;
window.deleteTransaction = deleteTransaction;
window.deleteAccount = deleteAccount;
window.editAccount = editAccount;
window.editTransaction = editTransaction;
window.applyFilters = applyFilters;
window.clearFilters = clearFilters;
window.generateReport = generateReport;
window.printReport = printReport;
window.exportReport = exportReport;
window.syncWithSupplyChain = syncWithSupplyChain;
window.exportData = exportData;
window.clearCache = clearCache;
window.resetSystem = resetSystem;
window.hideModal = hideModal;
window.calculateTotal = function() {
  const transactionQuantity = document.getElementById('transactionQuantity');
  const transactionPrice = document.getElementById('transactionPrice');
  const transactionAmount = document.getElementById('transactionAmount');
  
  if (transactionQuantity && transactionPrice && transactionAmount) {
    const qty = parseFloat(transactionQuantity.value) || 0;
    const price = parseFloat(transactionPrice.value) || 0;
    const total = qty * price;
    transactionAmount.value = total.toFixed(2);
  }
};

// Console logging for debugging
console.log('Aditya Fertilizers Ledger System - JavaScript Loaded');
console.log('Available functions:', {
  accountManager,
  transactionManager,
  showAddTransactionModal,
  showAddAccountModal,
  loadDashboard,
  loadAccounts,
  loadTransactions,
  loadReports
});
  </script>
</body>
</html>
